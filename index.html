<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Time Tracker</title>
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #4f46e5;
      --accent-hover: #4338ca;
      --danger: #ef4444;
      --danger-hover: #dc2626;
      --success: #10b981;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 50% -10%, #1f2937, var(--bg));
      color: var(--text);
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .app {
      width: 100%;
      max-width: 960px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0));
      border: 1px solid rgba(148,163,184,0.16);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.04);
    }
    .layout { display: grid; grid-template-columns: 1fr 320px; gap: 16px; align-items: stretch; }
    .main { display: block; }
    .tasks {
      background: rgba(17,24,39,0.55);
      border: 1px solid rgba(148,163,184,0.16);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.2);
      display: flex; flex-direction: column; min-height: 100%;
    }
    .tasks h3 { margin: 0 0 8px; font-size: 16px; color: var(--text); }
    .task-input-row { display: flex; gap: 8px; margin-bottom: 10px; }
    .task-input-row input[type="text"] {
      flex: 1 1 auto;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(17,24,39,0.6);
      color: var(--text);
      outline: none;
    }
    .task-input-row button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.25);
      background: linear-gradient(180deg, rgba(79,70,229,0.18), rgba(79,70,229,0.12));
      color: var(--text);
      cursor: pointer;
    }
    .task-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; overflow: auto; }
    .task-item { display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; padding: 8px; border: 1px solid rgba(148,163,184,0.15); border-radius: 8px; background: rgba(17,24,39,0.5); }
    .task-item.completed .title { text-decoration: line-through; color: var(--muted); }
    .task-item .title { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .task-item button.delete { border: 1px solid rgba(239,68,68,0.35); background: rgba(239,68,68,0.15); color: var(--text); border-radius: 8px; padding: 6px 8px; cursor: pointer; }
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 14px;
    }
    .title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }
    .timer {
      display: grid;
      grid-template-columns: 1fr;
      align-items: center;
      gap: 16px;
      background: rgba(17,24,39,0.55);
      border: 1px solid rgba(148,163,184,0.16);
      padding: 24px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.2);
    }
    .progress {
      width: 100%;
      height: 14px; /* already increased */
      background: rgba(148,163,184,0.18);
      border: 1px solid rgba(148,163,184,0.22);
      border-radius: 999px;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #10b981, #4f46e5);
      transition: width 0.3s ease;
      border-radius: 999px;
    }
    /* Progress row with small time chip */
    .progress-row { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      margin-bottom: 4px;
    }
    .progress-row .progress { flex: 1 1 auto; }
    .time-chip {
      font-variant-numeric: tabular-nums;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.3);
      background: rgba(31,41,55,0.8);
      color: var(--text);
      font-size: 15px;
      font-weight: 500;
      white-space: nowrap;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.05);
      transition: all 0.2s ease;
    }
    
    #restValDisplay {
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: #fca5a5;
      font-weight: 600;
      min-width: 90px;
      text-align: center;
    }
    
    #restValDisplay:hover {
      background: rgba(239, 68, 68, 0.2);
      transform: translateY(-1px);
    }
    /* Time Display Styling */
    #timeDisplay {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(79, 70, 229, 0.15));
      border: 1px solid rgba(79, 70, 229, 0.3);
      color: #e0f2fe;
      font-size: 16px;
      font-weight: 600;
      padding: 8px 18px;
      border-radius: 999px;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      transition: all 0.25s ease;
      letter-spacing: 0.5px;
    }
    
    #timeDisplay:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.15);
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(79, 70, 229, 0.2));
    }
    
    /* Other unified pill styling */
    #timeDisplay.time-chip,
    .rest .paused-ongoing {
      border-radius: 999px;
      padding: 6px 12px;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(31,41,55,0.7);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
    }
    .time {
      font-variant-numeric: tabular-nums;
      font-size: clamp(72px, 14vw, 185px);
      font-weight: 500;
      letter-spacing: 0.5px;
      line-height: 1.05;
      text-align: center;
      text-shadow: none;
    }
    .time.paused-color { color: #861414; transition: color 0.25s ease; }
    .rest {
      font-variant-numeric: tabular-nums;
      font-size: 14px;
      opacity: 0.9;
      margin-top: 2px; /* tighter spacing above */
      display: flex;
      justify-content: flex-end;
      align-items: center;
      width: 100%;
    }
    .rest .paused-ongoing {
      color: #93c5fd;
      opacity: 0.95;
      font-size: 16px;
      font-weight: 600;
      display: inline-block;
      background: rgba(96,165,250,0.15);
      border: 1px solid rgba(96,165,250,0.3);
      justify-self: end;
      text-align: right;
      padding: 8px 16px;
      border-radius: 999px;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .rest .paused-ongoing:hover {
      background: rgba(96,165,250,0.2);
      transform: translateY(-1px);
    }
    .goal {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      margin-left: 10px;
    }
    .goal input[type="number"] {
      width: 64px;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(17,24,39,0.6);
      color: var(--text);
      outline: none;
    }
    .quote {
      color: var(--muted);
      font-size: 14px;
      font-style: italic;
      text-align: center;
      margin: 6px 0 12px;
      opacity: 0.95;
    }
    button {
      appearance: none;
      border: 1px solid rgba(148,163,184,0.25);
      background: linear-gradient(180deg, rgba(79,70,229,0.18), rgba(79,70,229,0.12));
      color: var(--text);
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, background 0.2s ease, border-color 0.2s ease;
    }
    button:hover { transform: translateY(-1px); }
    .start { background: linear-gradient(180deg, rgba(16,185,129,0.25), rgba(16,185,129,0.12)); }
    .start:hover { background: linear-gradient(180deg, rgba(16,185,129,0.35), rgba(16,185,129,0.18)); }
    .pause { background: linear-gradient(180deg, rgba(79,70,229,0.25), rgba(79,70,229,0.12)); }
    .pause:hover { background: linear-gradient(180deg, rgba(79,70,229,0.35), rgba(79,70,229,0.18)); }
    .reset { background: linear-gradient(180deg, rgba(239,68,68,0.2), rgba(239,68,68,0.1)); }
    .reset:hover { background: linear-gradient(180deg, rgba(239,68,68,0.3), rgba(239,68,68,0.16)); }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 18px;
      font-size: 14px;
      background: rgba(17,24,39,0.6);
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 12px;
      overflow: hidden;
    }
    thead { background: rgba(148,163,184,0.15); position: sticky; top: 0; z-index: 1; }
    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(148,163,184,0.15);
    }
    /* Make comment column wider */
    .comment-col { width: 48%; }
    tbody tr:last-child td { border-bottom: none; }
    /* Scrollable body showing ~10 rows (approx 42px each) */
    tbody { display: block; max-height: 420px; overflow-y: auto; }
    thead, tbody tr { display: table; width: 100%; table-layout: fixed; }
    tbody tr.started-row { background: rgba(16,185,129,0.06); }
    tbody tr.paused-row { background: rgba(239,68,68,0.06); }
    /* Zebra striping overlay */
    tbody tr:nth-child(even) { filter: brightness(1.03); }
    

    /* Delta badge styling */
    .chip {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      line-height: 1.2;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(148,163,184,0.15);
      color: var(--text);
      margin-right: 8px;
      white-space: nowrap;
    }
    .chip.session { background: rgba(79,70,229,0.18); border-color: rgba(79,70,229,0.3); }
    .chip.pause { background: rgba(239,68,68,0.18); border-color: rgba(239,68,68,0.3); }
    .delta-val { font-variant-numeric: tabular-nums; font-weight: 600; }

    /* Comment input */
    .comment-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(17,24,39,0.6);
      color: var(--text);
      outline: none;
    }

    @media (max-width: 640px) {
      .time { font-size: 36px; }
      .timer { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="layout">
      <div class="main">
        <div class="quote" id="quote">Time you enjoy wasting is not wasted time.</div>
        <div class="header">
      <div class="title">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M12 8v5l4 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="12" cy="13" r="9" stroke="currentColor" stroke-width="2"/>
        </svg>
        <label class="goal" for="goalHours">Goal (h):
          <input id="goalHours" type="number" min="0.1" step="0.5" value="10" />
        </label>
        <button id="startBtn" class="start">Start</button>
        <button id="pauseBtn" class="pause" style="display:none;">Pause</button>
      </div>
      <div class="btns-right">
        <button id="exportBtn" title="Download CSV of logs">Export CSV</button>
        <button id="resetBtn" class="reset" title="Clear timer and logs">Reset</button>
      </div>
        </div>

        <div class="timer">
      <div class="progress-row">
        <div class="progress" aria-label="Progress to goal">
          <div id="progressBar" class="progress-bar"></div>
        </div>
        <span id="timeDisplay" class="paused-ongoing">00:00:00</span>
      </div>
      <div class="progress-row" style="margin-top: 10px;">
        <div class="progress" aria-label="Rest time progress">
          <div id="restProgressBar" class="progress-bar" style="background: linear-gradient(90deg, #f87171, #ef4444);"></div>
        </div>
        <span id="restValDisplay" class="time-chip">00:00:00</span>
      </div>
      <div id="pausedOngoing" class="time">00:00:00</div>
      <div id="restDisplay" class="rest">
        <!-- Rest time progress is now shown in the progress bar above -->
      </div>
        </div>

        <table aria-label="Play/Pause Log">
      <thead>
        <tr>
          <th>..Status</th>
          <th>End Time</th>
          <th class="comment-col">Comment</th>
        </tr>
      </thead>
      <tbody id="logBody">
        <!-- rows injected here -->
      </tbody>
        </table>
      </div>
      <aside class="tasks" aria-label="Upcoming Tasks">
        <h3>Upcoming Tasks</h3>
        <div class="task-input-row">
          <input id="taskInput" type="text" placeholder="Add a task" />
          <button id="taskAddBtn">Add</button>
        </div>
        <ul id="taskList" class="task-list"></ul>
      </aside>
    </div>
  </div>

  <script>
    (function() {
      const LS_STATE = 'timer_state_v1';
      const LS_LOGS = 'timer_logs_v1';
      const LS_RESET_FLAG = 'timer_reset_flag_v1';
      const LS_GOAL_HOURS = 'timer_goal_hours_v1';
      const LS_TASKS = 'timer_tasks_v1';
      const STATUS_STARTED = 'Started';
      const STATUS_PAUSED = 'Paused';
      const QUOTES = [
        'Time you enjoy wasting is not wasted time. — Marthe Troly-Curtin',
        'The key is in not spending time, but in investing it. — Stephen R. Covey',
        'It’s not that we have little time, but more that we waste a good deal of it. — Seneca',
        'Lost time is never found again. — Benjamin Franklin',
        'The bad news is time flies. The good news is you’re the pilot. — Michael Altshuler'
      ];

      const timeDisplay = document.getElementById('timeDisplay');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const exportBtn = document.getElementById('exportBtn');
      const logBody = document.getElementById('logBody');
      const goalInput = document.getElementById('goalHours');
      const taskInput = document.getElementById('taskInput');
      const taskAddBtn = document.getElementById('taskAddBtn');
      const taskList = document.getElementById('taskList');

      let state = {
        running: false,
        startTs: null,        // epoch ms when last started
        elapsedMs: 0,         // accumulated running time (not including current run)
        lastStartTs: null,    // for computing time used at pause
        lastPauseTs: null     // for computing rest time at start
      };

      let logs = [];
      let intervalId = null;
      let pauseUiIntervalId = null; // updates paused counter while paused
      let tasks = [];

      function fmt(ms) {
        ms = Math.max(0, Math.floor(ms));
        const totalSec = Math.floor(ms / 1000);
        const hh = String(Math.floor(totalSec / 3600)).padStart(2, '0');
        const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
        const ss = String(totalSec % 60).padStart(2, '0');
        return `${hh}:${mm}:${ss}`;
      }

      function renderTasks() {
        if (!taskList) return;
        taskList.innerHTML = '';
        for (const item of tasks) {
          const li = document.createElement('li');
          li.className = 'task-item' + (item.completed ? ' completed' : '');
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !!item.completed;
          cb.addEventListener('change', () => { item.completed = cb.checked; persist(); renderTasks(); });
          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = item.title || '';
          const del = document.createElement('button');
          del.className = 'delete';
          del.textContent = 'Delete';
          del.addEventListener('click', () => {
            tasks = tasks.filter(t => t.id !== item.id);
            persist();
            renderTasks();
          });
          li.appendChild(cb);
          li.appendChild(title);
          li.appendChild(del);
          taskList.appendChild(li);
        }
      }

      function addTaskFromInput() {
        if (!taskInput) return;
        const v = (taskInput.value || '').trim();
        if (!v) return;
        tasks.unshift({ id: Date.now() + ':' + Math.random().toString(36).slice(2,7), title: v, completed: false });
        taskInput.value = '';
        persist();
        renderTasks();
      }

      function now() { return Date.now(); }

      function persist() {
        try {
          localStorage.setItem(LS_STATE, JSON.stringify(state));
          localStorage.setItem(LS_LOGS, JSON.stringify(logs));
          localStorage.setItem(LS_TASKS, JSON.stringify(tasks));
        } catch (e) { /* ignore quota */ }
      }

      function restore() {
        try {
          if (localStorage.getItem(LS_RESET_FLAG) === 'true') {
            localStorage.removeItem(LS_STATE);
            localStorage.removeItem(LS_LOGS);
            localStorage.removeItem(LS_RESET_FLAG);
          }
          const s = localStorage.getItem(LS_STATE);
          const l = localStorage.getItem(LS_LOGS);
          const gh = localStorage.getItem(LS_GOAL_HOURS);
          const tks = localStorage.getItem(LS_TASKS);
          if (s) state = Object.assign(state, JSON.parse(s));
          if (l) logs = JSON.parse(l);
          if (goalInput && gh) goalInput.value = String(gh);
          if (tks) tasks = JSON.parse(tks);
        } catch (e) { /* ignore parse errors */ }
      }

      function liveElapsedMs() {
        return (state.running && state.startTs) ? (now() - state.startTs) : 0;
      }

      function renderTime() {
        timeDisplay.textContent = fmt(state.elapsedMs + liveElapsedMs());
      }

      function goalMs() {
        let h = 10;
        if (goalInput) {
          const v = parseFloat(goalInput.value);
          if (!isNaN(v) && v > 0) h = v;
        }
        return h * 60 * 60 * 1000;
      }
      function renderProgress() {
        const bar = document.getElementById('progressBar');
        if (!bar) return;
        const total = state.elapsedMs + liveElapsedMs();
        const pct = Math.max(0, Math.min(100, (total / goalMs()) * 100));
        bar.style.width = pct.toFixed(2) + '%';
      }

      function totalRestMs() {
        const loggedRest = logs.reduce((acc, item) => acc + (item.restMs || 0), 0);
        // If currently paused, add the ongoing rest time since last pause
        const ongoingRest = (!state.running && state.lastPauseTs) ? (now() - state.lastPauseTs) : 0;
        return loggedRest + ongoingRest;
      }

      function renderRest() {
        const pausedOngoingEl = document.getElementById('pausedOngoing');
        const restMs = totalRestMs();
        const restValDisplay = document.getElementById('restValDisplay');
        
        if (restValDisplay) restValDisplay.textContent = fmt(restMs);
        
        // Update rest progress bar
        const restProgressBar = document.getElementById('restProgressBar');
        if (restProgressBar) {
          const goal = goalMs();
          const pct = Math.max(0, Math.min(100, (restMs / goal) * 100));
          restProgressBar.style.width = pct.toFixed(2) + '%';
        }
        if (pausedOngoingEl) {
          let label = state.running ? 'Running' : 'Paused';
          let ms = 0;
          if (state.running && state.lastStartTs) {
            ms = now() - state.lastStartTs;
          } else if (!state.running && state.lastPauseTs) {
            ms = now() - state.lastPauseTs;
          }
          pausedOngoingEl.textContent =  fmt(ms);
          if (!state.running) {
            pausedOngoingEl.classList.add('paused-color');
          } else {
            pausedOngoingEl.classList.remove('paused-color');
          }
        }
      }

      function exportCsv() {
        const rows = [['dateTime','status','comment']];
        const sorted = [...logs].sort((a,b) => (a.at || 0) - (b.at || 0));
        for (const item of sorted) {
          rows.push([new Date(item.at).toLocaleString(), item.status, item.comment || '']);
        }
        const csv = rows
          .map(r => r.map(v => '"' + String(v).replace(/"/g,'""') + '"').join(','))
          .join('\r\n');
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const d = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const dateStr = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
        a.download = `date_time_tracking_${dateStr}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      function renderButtons() {
        if (state.running) {
          startBtn.style.display = 'none';
          pauseBtn.style.display = '';
        } else {
          startBtn.style.display = '';
          pauseBtn.style.display = 'none';
        }
      }

      function renderLogs() {
        logBody.innerHTML = '';
        const sorted = [...logs].sort((a, b) => (b.at || 0) - (a.at || 0));
        for (const item of sorted) {
          const tr = document.createElement('tr');
          tr.className = item.status === STATUS_STARTED ? 'started-row' : 'paused-row';
          const dtTd = document.createElement('td');
          const deltaTd = document.createElement('td');
          const commentTd = document.createElement('td');
          commentTd.className = 'comment-col';

          dtTd.textContent = new Date(item.at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
          const isStart = item.status === STATUS_STARTED;
          const chip = document.createElement('span');
          chip.className = 'chip ' + (isStart ? 'pause' : 'session');
          chip.textContent = isStart ? 'Paused.' : 'Session';
          const val = document.createElement('span');
          val.className = 'delta-val';
          val.textContent = ((ms)=>{ms=Math.max(0,ms|0);const m=Math.floor(ms/60000),h=Math.floor(m/60);return String(h).padStart(2,'0')+':'+String(m%60).padStart(2,'0')})(isStart ? (item.restMs||0) : (item.timeUsedMs||0));
          deltaTd.appendChild(chip);
          deltaTd.appendChild(val);

          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'comment-input';
          input.placeholder = 'Add comment';
          input.value = item.comment || '';
          input.addEventListener('change', () => {
            const idx = logs.findIndex(x => x && x.at === item.at && x.status === item.status);
            if (idx !== -1) {
              logs[idx].comment = input.value;
              persist();
            }
          });
          commentTd.appendChild(input);

          tr.appendChild(deltaTd);
          tr.appendChild(dtTd);
          tr.appendChild(commentTd);
          logBody.appendChild(tr);
        }
      }

      function startInterval() {
        if (intervalId) return;
        intervalId = setInterval(() => {
          renderTime();
          renderProgress();
          renderRest();
          // store lightweight state to survive refresh while running
          persist();
        }, 1000);
      }

      function stopInterval() {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
      }

      function onStart() {
        const t = now();
        // If resuming from pause, compute rest time since last pause
        let restMs = 0;
        if (!state.running && state.lastPauseTs) {
          restMs = t - state.lastPauseTs;
        }
        state.running = true;
        state.startTs = t;
        state.lastStartTs = t;

        logs.push({
          status: STATUS_STARTED,
          at: t,
          timeUsedMs: state.elapsedMs, // elapsed so far before starting again
          restMs
        });

        // stop paused-only UI ticker if any
        if (pauseUiIntervalId) {
          clearInterval(pauseUiIntervalId);
          pauseUiIntervalId = null;
        }

        renderButtons();
        renderLogs();
        startInterval();
        persist();
        renderTime();
        renderProgress();
        renderRest();
      }

      function onPause() {
        if (!state.running) return;
        const t = now();
        const thisRun = t - (state.startTs || t);
        state.elapsedMs += thisRun;
        state.running = false;
        state.startTs = null;

        let timeUsedMs = 0;
        if (state.lastStartTs) {
          timeUsedMs = t - state.lastStartTs;
        }
        state.lastPauseTs = t;

        logs.push({
          status: STATUS_PAUSED,
          at: t,
          timeUsedMs,
          restMs: 0
        });

        stopInterval();
        // start a lightweight ticker to update paused duration every second while paused
        if (!pauseUiIntervalId) {
          pauseUiIntervalId = setInterval(() => {
            renderRest();
          }, 1000);
        }
        renderButtons();
        renderLogs();
        persist();
        renderTime();
        renderProgress();
        renderRest();
      }

      function onReset() {
        const ok = confirm('Reset all data (timer and logs)?');
        if (!ok) return;
        // Export logs before clearing
        try { exportCsv(); } catch (e) {}
        try {
          // mark flag first, then clear our keys, then remove flag to keep storage tidy
          localStorage.setItem(LS_RESET_FLAG, 'true');
          localStorage.removeItem(LS_STATE);
          localStorage.removeItem(LS_LOGS);
          localStorage.removeItem(LS_RESET_FLAG);
        } catch (e) {}

        stopInterval();
        if (pauseUiIntervalId) {
          clearInterval(pauseUiIntervalId);
          pauseUiIntervalId = null;
        }
        state = { running: false, startTs: null, elapsedMs: 0, lastStartTs: null, lastPauseTs: null };
        logs = [];
        renderButtons();
        renderLogs();
        renderTime();
        renderProgress();
        renderRest();
      }

      // Wire up events
      startBtn.addEventListener('click', onStart);
      pauseBtn.addEventListener('click', onPause);
      resetBtn.addEventListener('click', onReset);
      if (exportBtn) exportBtn.addEventListener('click', exportCsv);
      if (goalInput) {
        goalInput.addEventListener('input', () => {
          const v = parseFloat(goalInput.value);
          if (isNaN(v) || v <= 0) return; // ignore invalid
          try { localStorage.setItem(LS_GOAL_HOURS, String(v)); } catch (e) {}
          renderProgress();
        });
      }

      if (taskAddBtn) taskAddBtn.addEventListener('click', addTaskFromInput);
      if (taskInput) taskInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addTaskFromInput(); });

      // Keyboard: Space toggles Start/Pause (unless typing in fields)
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
          const tag = (e.target && e.target.tagName ? e.target.tagName : '').toLowerCase();
          const isEditable = e.target && (e.target.isContentEditable || tag === 'input' || tag === 'textarea');
          if (isEditable) return; // do not hijack typing
          e.preventDefault(); // prevent page scroll / default button click
          if (state.running) {
            onPause();
          } else {
            onStart();
          }
        }
      });

      // Init
      restore();
      // Quote
      (function setQuote(){
        const qEl = document.getElementById('quote');
        if (!qEl) return;
        try {
          const q = QUOTES[Math.floor(Math.random() * QUOTES.length)];
          if (q) qEl.textContent = q;
        } catch (e) {}
      })();
      renderLogs();

      if (state.running && state.startTs) {
        // Adjust for time elapsed while page was closed
        // Keep startTs as recorded so total shows correctly
        renderButtons();
        startInterval();
      } else {
        renderButtons();
      }
      renderTime();
      renderProgress();
      renderRest();
      renderTasks();

      // Persist once on load to ensure structure exists
      persist();
    })();
  </script>
</body>
</html>
